# cast
***** Lexer *****
Reading from stdin
# let f (x:?) = x in
let g (y:int->int) = f y in
g ((fun z -> z + 1):?) (true:?);;
***** Parser *****
e: let f = fun (x: ?) -> x in let g = fun (y: int -> int) -> f y in g ((fun (z: 'x10) -> z + 1) : ?) (true : ?)
***** Typing *****
e: let f = fun (x: ?) -> x in let g = fun (y: int -> int) -> f y in g ((fun (z: int) -> z + 1) : ?) (true : ?)
U: ?
***** Cast-insertion *****
f: let f = fun (x: ?) -> x in let g = fun (y: int -> int) -> f (y: int -> int => ?) in (g ((fun (z: int) -> z + 1): int -> int => ? => int -> int): ? => ? -> ?) (true: bool => ?)
U: ?
***** Eval *****
eval <-- let f = fun (x: ?) -> x in let g = fun (y: int -> int) -> f (y: int -> int => ?) in (g ((fun (z: int) -> z + 1): int -> int => ? => int -> int): ? => ? -> ?) (true: bool => ?)
eval <-- fun (x: ?) -> x
eval <-- let g = fun (y: int -> int) -> f (y: int -> int => ?) in (g ((fun (z: int) -> z + 1): int -> int => ? => int -> int): ? => ? -> ?) (true: bool => ?)
eval <-- fun (y: int -> int) -> f (y: int -> int => ?)
eval <-- (g ((fun (z: int) -> z + 1): int -> int => ? => int -> int): ? => ? -> ?) (true: bool => ?)
eval <-- g ((fun (z: int) -> z + 1): int -> int => ? => int -> int): ? => ? -> ?
eval <-- g ((fun (z: int) -> z + 1): int -> int => ? => int -> int)
eval <-- g
eval <-- (fun (z: int) -> z + 1): int -> int => ? => int -> int
eval <-- (fun (z: int) -> z + 1): int -> int => ?
eval <-- fun (z: int) -> z + 1
cast <-- <fun>: int -> int => ?
cast <-- <fun>: int -> int => ? -> ?
cast <-- <fun>: ? -> ? => ?
cast <-- <fun>: (? -> ?) => ?: ? => int -> int
cast <-- <fun>: (? -> ?) => ?: ? => ? -> ?
cast <-- <fun>: ? -> ? => int -> int
eval <-- f (y: int -> int => ?)
eval <-- f
eval <-- y: int -> int => ?
eval <-- y
cast <-- <fun>: int -> int => ?
cast <-- <fun>: int -> int => ? -> ?
cast <-- <fun>: ? -> ? => ?
eval <-- x
cast <-- <fun>: (? -> ?) => ?: ? => ? -> ?
eval <-- true: bool => ?
eval <-- true
cast <-- true: bool => ?
cast <-- true: bool => ?: ? => int
Blame on the environment side:
line 2, character 23 -- line 2, character 24

# coercion
***** Lexer *****
Reading from stdin
# let f (x:?) = x in
let g (y:int->int) = f y in
g ((fun z -> z + 1):?) (true:?);;
***** Parser *****
e: let f = fun (x: ?) -> x in let g = fun (y: int -> int) -> f y in g ((fun (z: 'x10) -> z + 1) : ?) (true : ?)
***** Typing *****
e: let f = fun (x: ?) -> x in let g = fun (y: int -> int) -> f y in g ((fun (z: int) -> z + 1) : ?) (true : ?)
U: ?
***** Coercion-insertion *****
f: let f = fun (x: ?) -> x in let g = fun (y: int -> int) -> f (y<(int?p;id{int})->(id{int};int!);(? -> ?)!>) in (g ((fun (z: int) -> z + 1)<(int?p;id{int})->(id{int};int!);(? -> ?)!><(? -> ?)?p;(id{int};int!)->(int?p;id{int})>)<(? -> ?)?p;id{? -> ?}>) (true<id{bool};bool!>)
U: ?
***** CPS-translation *****
f: let f = fun ((x: ?), k13) -> x<k13> in let g = fun ((y: int -> int), k12) -> f (y<(int?p;id{int})->(id{int};int!);(? -> ?)!>, k12) in g (let k10 = (int?p;id{int})->(id{int};int!);(? -> ?)!;;(? -> ?)?p;(id{int};int!)->(int?p;id{int}) in (fun ((z: int), k11) -> (z + 1)<k11>)<k10>, (? -> ?)?p;id{? -> ?}) (true<id{bool};bool!>, id{?})
***** Eval *****
eval <-- let f = fun ((x: ?), k13) -> x<k13> in let g = fun ((y: int -> int), k12) -> f (y<(int?p;id{int})->(id{int};int!);(? -> ?)!>, k12) in g (let k10 = (int?p;id{int})->(id{int};int!);(? -> ?)!;;(? -> ?)?p;(id{int};int!)->(int?p;id{int}) in (fun ((z: int), k11) -> (z + 1)<k11>)<k10>, (? -> ?)?p;id{? -> ?}) (true<id{bool};bool!>, id{?})
eval <-- fun ((x: ?), k13) -> x<k13>
eval <-- let g = fun ((y: int -> int), k12) -> f (y<(int?p;id{int})->(id{int};int!);(? -> ?)!>, k12) in g (let k10 = (int?p;id{int})->(id{int};int!);(? -> ?)!;;(? -> ?)?p;(id{int};int!)->(int?p;id{int}) in (fun ((z: int), k11) -> (z + 1)<k11>)<k10>, (? -> ?)?p;id{? -> ?}) (true<id{bool};bool!>, id{?})
eval <-- fun ((y: int -> int), k12) -> f (y<(int?p;id{int})->(id{int};int!);(? -> ?)!>, k12)
eval <-- g (let k10 = (int?p;id{int})->(id{int};int!);(? -> ?)!;;(? -> ?)?p;(id{int};int!)->(int?p;id{int}) in (fun ((z: int), k11) -> (z + 1)<k11>)<k10>, (? -> ?)?p;id{? -> ?}) (true<id{bool};bool!>, id{?})
eval <-- g (let k10 = (int?p;id{int})->(id{int};int!);(? -> ?)!;;(? -> ?)?p;(id{int};int!)->(int?p;id{int}) in (fun ((z: int), k11) -> (z + 1)<k11>)<k10>, (? -> ?)?p;id{? -> ?})
eval <-- g
eval <-- let k10 = (int?p;id{int})->(id{int};int!);(? -> ?)!;;(? -> ?)?p;(id{int};int!)->(int?p;id{int}) in (fun ((z: int), k11) -> (z + 1)<k11>)<k10>
eval <-- (int?p;id{int})->(id{int};int!);(? -> ?)!;;(? -> ?)?p;(id{int};int!)->(int?p;id{int})
eval <-- (int?p;id{int})->(id{int};int!);(? -> ?)!
eval <-- (? -> ?)?p;(id{int};int!)->(int?p;id{int})
compose <-- (int?p;id{int})->(id{int};int!);(? -> ?)!；(? -> ?)?p;(id{int};int!)->(int?p;id{int})
compose <-- (int?p;id{int})->(id{int};int!)；(id{int};int!)->(int?p;id{int})
compose <-- id{int};int!；int?p;id{int}
compose <-- id{int}；id{int}
compose <-- id{int};int!；int?p;id{int}
compose <-- id{int}；id{int}
eval <-- (fun ((z: int), k11) -> (z + 1)<k11>)<k10>
eval <-- fun ((z: int), k11) -> (z + 1)<k11>
eval <-- k10
coerce <-- <fun><id{int -> int}>
eval <-- (? -> ?)?p;id{? -> ?}
eval <-- f (y<(int?p;id{int})->(id{int};int!);(? -> ?)!>, k12)
eval <-- f
eval <-- y<(int?p;id{int})->(id{int};int!);(? -> ?)!>
eval <-- y
eval <-- (int?p;id{int})->(id{int};int!);(? -> ?)!
coerce <-- <fun><(int?p;id{int})->(id{int};int!);(? -> ?)!>
eval <-- k12
eval <-- x<k13>
eval <-- x
eval <-- k13
coerce <-- <fun><<(int?p;id{int})->(id{int};int!);(? -> ?)!>><(? -> ?)?p;id{? -> ?}>
compose <-- (int?p;id{int})->(id{int};int!);(? -> ?)!；(? -> ?)?p;id{? -> ?}
compose <-- (int?p;id{int})->(id{int};int!)；id{? -> ?}
coerce <-- <fun><(int?p;id{int})->(id{int};int!)>
eval <-- true<id{bool};bool!>
eval <-- true
eval <-- id{bool};bool!
coerce <-- true<id{bool};bool!>
eval <-- id{?}
compose <-- id{int};int!；id{?}
coerce <-- true<<id{bool};bool!>><int?p;id{int}>
compose <-- id{bool};bool!；int?p;id{int}
coerce <-- true<⊥{bool,p,int}>
Blame on the environment side:
line 2, character 23 -- line 2, character 24